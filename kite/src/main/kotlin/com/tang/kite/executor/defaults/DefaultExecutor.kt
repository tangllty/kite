package com.tang.kite.executor.defaults

import com.tang.kite.executor.Executor
import com.tang.kite.session.Configuration
import com.tang.kite.sql.BatchSqlStatement
import com.tang.kite.sql.SqlStatement
import com.tang.kite.transaction.Transaction
import com.tang.kite.utils.ResultSetHandlers
import com.tang.kite.utils.Statements
import org.slf4j.LoggerFactory
import java.sql.Connection
import java.sql.Statement

/**
 * @author Tang
 */
class DefaultExecutor(

    private val configuration: Configuration,

    private val transaction: Transaction

) : Executor {

    private val logger = LoggerFactory.getLogger(DefaultExecutor::class.java)

    override fun getConnection(): Connection {
        return transaction.getConnection()
    }

    override fun <T> count(statement: SqlStatement, type: Class<T>): Long {
        val connection = getConnection()
        val preparedStatement = connection.prepareStatement(statement.sql)
        statement.setValues(preparedStatement)
        return runCatching {
            val resultSet = preparedStatement.executeQuery()
            ResultSetHandlers.getCount(resultSet)
        }.onFailure {
            it.printStackTrace()
            connection.rollback()
        }.also {
            logger.debug("Closing count prepared statement [{}]", preparedStatement)
            preparedStatement.close()
        }.getOrDefault(0)
    }

    override fun <T> query(statement: SqlStatement, type: Class<T>): List<T> {
        val connection = getConnection()
        val preparedStatement = connection.prepareStatement(statement.sql)
        statement.setValues(preparedStatement)
        return runCatching {
            val resultSet = preparedStatement.executeQuery()
            ResultSetHandlers.getList(resultSet, type)
        }.onFailure {
            it.printStackTrace()
            connection.rollback()
        }.also {
            logger.debug("Closing query prepared statement [{}]", preparedStatement)
            preparedStatement.close()
        }.getOrDefault(emptyList())
    }

    override fun update(statement: SqlStatement, parameter: Any): Int {
        val connection = getConnection()
        val autoGeneratedKeys = if (ResultSetHandlers.hasGeneratedKey(statement.sql, parameter)) {
            Statement.RETURN_GENERATED_KEYS
        } else {
            Statement.NO_GENERATED_KEYS
        }
        val preparedStatement = connection.prepareStatement(statement.sql, autoGeneratedKeys)
        statement.setValues(preparedStatement)
        return runCatching {
            preparedStatement.executeUpdate()
        }.onFailure {
            it.printStackTrace()
            connection.rollback()
        }.also {
            ResultSetHandlers.setGeneratedKey(statement.sql, preparedStatement, parameter)
            logger.debug("Closing update prepared statement [{}]", preparedStatement)
            preparedStatement.close()
        }.getOrDefault(0)
    }

    override fun update(batchSqlStatement: BatchSqlStatement, parameters: List<Any>): Int {
        val connection = getConnection()
        var totalUpdatedRows = 0
        val autoGeneratedKeys = if (ResultSetHandlers.hasGeneratedKey(batchSqlStatement.sql, parameters.first())) {
            Statement.RETURN_GENERATED_KEYS
        } else {
            Statement.NO_GENERATED_KEYS
        }
        val preparedStatement = connection.prepareStatement(batchSqlStatement.sql, autoGeneratedKeys)
        for (parameter in batchSqlStatement.parameters) {
            Statements.setValues(preparedStatement, parameter)
            preparedStatement.addBatch()
        }
        totalUpdatedRows += runCatching {
            preparedStatement.executeBatch().sum()
        }.onFailure {
            it.printStackTrace()
            connection.rollback()
        }.also {
            ResultSetHandlers.setGeneratedKey(batchSqlStatement.sql, preparedStatement, parameters)
            logger.debug("Closing batch update prepared statement [{}]", preparedStatement)
            preparedStatement.close()
        }.getOrDefault(0)
        return totalUpdatedRows
    }

    override fun update(statements: List<SqlStatement>, parameters: List<Any>): Int {
        val connection = getConnection()
        var totalUpdatedRows = 0
        for (i in statements.indices) {
            val statement = statements[i]
            val parameter = parameters[i]
            val autoGeneratedKeys = if (ResultSetHandlers.hasGeneratedKey(statement.sql, parameter)) {
                Statement.RETURN_GENERATED_KEYS
            } else {
                Statement.NO_GENERATED_KEYS
            }
            val preparedStatement = connection.prepareStatement(statement.sql, autoGeneratedKeys)
            statement.setValues(preparedStatement)
            totalUpdatedRows += runCatching {
                preparedStatement.executeUpdate()
            }.onFailure {
                it.printStackTrace()
                connection.rollback()
            }.also {
                ResultSetHandlers.setGeneratedKey(statement.sql, preparedStatement, parameter)
                logger.debug("Closing batch update prepared statement [{}]", preparedStatement)
                preparedStatement.close()
            }.getOrDefault(0)
        }
        return totalUpdatedRows
    }

    override fun commit() {
        transaction.commit()
    }

    override fun rollback() {
        transaction.rollback()
    }

    override fun close() {
        transaction.close()
    }

}
